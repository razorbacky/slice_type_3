[Rust] Slice Type 3
===

### 슬라이스로써의 문자열 리터럴

문자열 리터럴은 바이너리 내에 저장된다.

```rust
let s = "Hello, world!";
```

여기서 s 는 바이너리의 특정 지점을 가리키는 슬라이스이다. **&str** 타입.

**&str**은 불변 참조자이므로, 'Slice Type 2-1'에서 문자열은 왜 변경할 수 없는지에 대한 의문도 해결된다.

### 문자열 슬라이스를 매개변수로 사용하기

리터럴과 String의 슬라이스를 만들 수 있다는 걸 알고 나면 first_word 함수 정의를 다음과 같이 작성할 수 있다.


```rust
fn first_word(s: &String) -> &str {
```

조금 더 경험이 많은 사람인 경우에는 다음 예제 처럼 &String 값과 &str 값 모두 사용 가능한 함수를 작성할 것이다.

```rust
fn first_word(s: &str) -> &str {
```

문자열 슬라이스라면 이를 바로 인수로써 전달할 수 있다. String 이라면 String 의 슬라이스 혹은 String 에 대한 참조자를 전달할 수 있다.
이러한 유연성은 역참조 강제 변환(deref coercions) 기능을 이용한다. ***15장의  '함수와 메서드를 이용한 암묵적 역참조 강제 변환'***에서 다룬다.

String에 대한 참조자 대신 문자열 슬라이스를 매개변수로 하는 함수를 만들면 기능 면에서 손해보지 않으면서 유연하게 만들 수 있다.

### 그 외 슬라이스

문자열 슬라이는 문자열에만 특정되어 있다. 더 범용적인 슬라이스 타입도 당연히 존재한다.

```rust
let a =  [1, 2, 3, 4, 5];
```

문자열 일부를 참조할 떄처럼 다음과 같이 배열 일부를 참조하고 싶다면 다음과 같이 할 수 있다.

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```

이 슬라이스는 &[i32] 타입이다. 동작 방식은 문자열 슬라이스와 동일하다.
슬라이스의 첫 번째 요소를 참조하는 참조자와 슬라이스의 길이를 저장하여 동작한다.
이런 슬라이스는 모든 컬렉션에서 사용이 가능하다.

***슬라이스 정리***
소유권(Ownership), 대여(Borrow), 슬라이스(Slice)는 Rust가 컴파일 타임에 메모리 안정성을 보장하는 비결이다.
다른 시스템 프로그래밍 언어들 처럼 메모리 사용 제어 권한을 주면서도 어떠한 데이터 소유자가 스코프를 벗어날 경우
자동으로 해당 데이터를 정리하는 것도 가능하다.
